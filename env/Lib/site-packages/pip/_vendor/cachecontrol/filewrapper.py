<<<<<<< HEAD
# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0
<<<<<<< HEAD
from __future__ import annotations

import mmap
from tempfile import NamedTemporaryFile
from typing import TYPE_CHECKING, Any, Callable

if TYPE_CHECKING:
    from http.client import HTTPResponse
=======

from tempfile import NamedTemporaryFile
import mmap
>>>>>>> refs/remotes/origin/main
=======
from io import BytesIO
>>>>>>> parent of c811851 (latest changes)


class CallbackFileWrapper(object):
    """
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.

    All attributes are proxied to the underlying file object.

    This class uses members with a double underscore (__) leading prefix so as
    not to accidentally shadow an attribute.
    """

<<<<<<< HEAD
<<<<<<< HEAD
    def __init__(
        self, fp: HTTPResponse, callback: Callable[[bytes], None] | None
    ) -> None:
=======
    def __init__(self, fp, callback):
>>>>>>> refs/remotes/origin/main
        self.__buf = NamedTemporaryFile("rb+", delete=True)
=======
    def __init__(self, fp, callback):
        self.__buf = BytesIO()
>>>>>>> parent of c811851 (latest changes)
        self.__fp = fp
        self.__callback = callback

    def __getattr__(self, name):
        # The vaguaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0] allows looking up the attribute value and raising an
        # AttributeError when it doesn't exist. This stop thigns from
        # infinitely recursing calls to getattr in the case where
        # self.__fp hasn't been set.
        #
        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers
        fp = self.__getattribute__("_CallbackFileWrapper__fp")
        return getattr(fp, name)

    def __is_fp_closed(self):
        try:
            return self.__fp.fp is None

        except AttributeError:
            pass

        try:
            return self.__fp.closed

        except AttributeError:
            pass

        # We just don't cache it then.
        # TODO: Add some logging here...
        return False

    def _close(self):
        if self.__callback:
            self.__callback(self.__buf.getvalue())

        # We assign this to None here, because otherwise we can get into
        # really tricky problems where the CPython interpreter dead locks
        # because the callback is holding a reference to something which
        # has a __del__ method. Setting this to None breaks the cycle
        # and allows the garbage collector to do it's thing normally.
        self.__callback = None

<<<<<<< HEAD
        # Closing the temporary file releases memory and frees disk space.
        # Important when caching big files.
        self.__buf.close()

<<<<<<< HEAD
    def read(self, amt: int | None = None) -> bytes:
        data: bytes = self.__fp.read(amt)
=======
    def read(self, amt=None):
        data = self.__fp.read(amt)
>>>>>>> refs/remotes/origin/main
        if data:
            # We may be dealing with b'', a sign that things are over:
            # it's passed e.g. after we've already closed self.__buf.
            self.__buf.write(data)
=======
    def read(self, amt=None):
        data = self.__fp.read(amt)
        self.__buf.write(data)
>>>>>>> parent of c811851 (latest changes)
        if self.__is_fp_closed():
            self._close()

        return data

    def _safe_read(self, amt):
        data = self.__fp._safe_read(amt)
        if amt == 2 and data == b"\r\n":
            # urllib executes this read to toss the CRLF at the end
            # of the chunk.
            return data

        self.__buf.write(data)
        if self.__is_fp_closed():
            self._close()

        return data
